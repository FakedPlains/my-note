---
displayed_sidebar: javaSidebar
---

# Java 基础 — 面向对象

## 三大特性

- ### 封装

    - 利用抽象数据类型将**数据**和**基于数据的操作**封装在一起，使其构成一个不可分割的独立实体。
    - 数据被保护在抽象数据类型的内部，尽可能地**隐藏内部的细节**，只保留一些**对外的接口**使之与外部发生联系。
    - 用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象
    - 四种访问权限修饰符：
        - **==private==（当前访问权限）**：这个成员只能在当前类的内部被访问
        - **==*default*==（包访问权限）**：这个成员或外部类可以被相同包下的其他类访问
        - **==protected==（子类访问权限）**：这个成员既可以被同一个包的其他类访问，也可以被不同包中的子类访问
        - **==public==（公共访问权限）**：这个成员或外部类可以被所有类访问

- ### 继承

    - 继承体现了 IS-A 关系，子类继承父类，从而获得父类**非 private 的属性和方法**
    - 继承应该遵循**里氏替换原则**，子类对象必须能够替换掉所有父类对象
    - 父类引用指向子类对象成为**向上转型**
    - Java 只支持单继承和多层继承，不允许多重继承

- ### 多态

    - 多态分为**编译时多态**和**运行时多态**：
        - 编译时多态主要指方法的重载
        - 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定
    - 运行时多态有三个条件
        - 继承
        - 覆盖（重写）
        - 向上转型
    - 对象的多态性：把一个子类对象直接赋给一个父类引用变量（**父类引用指向子类对象**或**向上转型**）
    - 当把一个子类对象直接赋给父类引用变量时，编译时类型是父类类型，而运行时类型是子类类型，当运行时调用该引用变量的方法时，其**方法行为总是表现出子类方法的特征**，这就可能出现：**相同类型的变量，调用同一个方法时呈现出多种不同的行为特征**，这就是**多态**
    - 引用变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行它运行时类型所具有的方法。因此，在编写 Java 代码的时，**引用变量只能调用声明该变量时所用类型包含的方法**

## 类和对象

- 类是具有相同特征或行为的一种抽象
- 对象是类的具体的实例

### 属性（成员变量）

- 变量的分类：

    - **成员变量：** 定义在类里的变量

        - 实例变量（不以 static 修饰）：作用域与**对应实例**的生存范围相同
        - 类变量（以 static 修饰）：作用域与这个**类**的生存范围相同

      >成员变量无须显示初始化，当一个对象被创建时，会对其中的**成员变量**进行初始化赋值

    - **局部变量**

        - 形参（方法、构造器中定义的变量）：在整个**方法**内有效
        - 方法局部变量（在方法中定义）：从**定义该变量的地方生效，到该方法结束失效**
        - 代码块局部变量（在代码块中定义）：从**定义该变量的地方生效，到该方法结束失效**

      > 局部变量除**形参**外，都必须显示初始化

- 一个类里不能定义两个同名的成员变量，一个方法里不能定义两个同名的方法局部变量，方法局部变量与形参也不能同名
- 如果方法里的局部变量和成员变量同名，**局部变量会覆盖成员变量**，如果需要在这个方法引用被覆盖的成员变量，则可使用 **this （对于实例变量）或类名（对于类变量）**作为调用者来限定访问成员变量

### 方法

- 方法是类或对象行为特征的抽象，不能独立存在，必须定义在类里
    - **形参：**方法声明时的参数
    - **实参：**方法调用时实际传给形参的参数值
- **方法的值传递机制**：
    - Java 中方法的参数传递方式只有一种：**值传递**，即将实际参数值的副本传入方法内，参数本身不受影响
    - **值传递的实质：**当系统开始执行方法时，系统位形参执行初始化，将实参变量的值赋给方法的形参，方法里操作的并不是实参变量
- **方法重载：**
    - 在同一个类中，允许存在一个以上的同名方法，只要它们的**形参列表**（参数个数或类型）不同就行
    - **与返回值类型无关**，要求**两同一不同**：同一类中方法名相同，参数列表不同
- **方法重写（Override）：**
    - 子类继承父类后，对从父类继承的方法进行改造，成为方法重写（方法覆盖）
    - 方法重写遵循 **“两同两小一大”** 规则：
        - **两同：****方法名**相同，**形参列表**相同
        - **两小：**子类方法的**返回值类型**小于或等于父类的，子类方法声明**抛出的异常类**小于或等于父类的
        - **一大：**子类方法的**访问权限**大于或等于父类的
    - ==**注意**==：方法重写的方法必须同时声明为类方法（不是重写）或实例方法
    - 当子类覆盖了父类方法后，子类对象将无法访问父类中被覆盖的方法，但可以在子类中**调用父类中被覆盖的方法**。使用 **super （被覆盖的是实例方法）**或者**父类类名（被覆盖的是类方法）**作为调用者来调用父类中被覆盖的方法

### 构造器

- 通过构造器来创建对象并给对象进行初始化
- 构造器的**特征**：
    - 构造器名必须**与类名相同**
    - 构造器**没有返回值类型**
    - 不能被static、final、synchronized、abstract、native修饰，不能有 return语句返回值
- Java 语言中，每个类至少有一个构造器
- 系统默认为每一个类提供一个**默认无参构造器**
- 一个类可以创建多个重载的构造器，一旦显示定义了构造器，系统不再提供默认构造器
- **父类的构造器不能被子类继承**

### 代码块

- 通过代码块对对象进行初始化
- 相同类型的初始化块之间由顺序：前面定义的初始化块先执行，后面定义的初始化块后执行
- **静态代码块：**用 static 修饰的代码块
    - **不能**调用非静态的属性和方法
    - 执行**优先于**非静态代码块
    - **静态代码块随着类的加载而加载，且只执行一次**
- **非静态代码块：**没有 static 修饰的代码块
    - **每次创建对象的时候，都会执行一次**
    - 在**构造器之前**执行

### this 关键字

- 根据 this 出现的位置不同，this 作为对象的默认引用有两种情形：
    - **构造器中：引用正在初始化的对象**
    - **方法中：引用调用该方法的对象**
- 在构造器中使用 **this 调用另一个重载的构造器**时，必须作为**构造器执行体的第一条语句**
- 对于 static 修饰的方法而言，则可以使用类直接调用该方法。**static 修饰的方法不能使用 this 引用。**

### super 关键字

- super 关键字用于限定该对象调用它从**父类继承得到的实例变量或方法**，**不能出现在 static 修饰的方法中**
- 子类中的所有构造器**默认总会调用父类的无参构造器**
- 当父类中没有空参数的构造器时，子类的构造器必须通过**this(参 数列表)**或者**super(参数列表)**语句指定调用本类或者父类中相应的 构造器。同时，只能**“二选一”** ，且必须放在**构造器的首行**

### static 关键字

- static 可以修饰**属性、方法、代码块、内部类**
- 被 static 修饰的成员的**特点：**
    - 随着类的加载而加载
    - 优先于对象存在
    - 修饰的成员被所有对象所共享
    - 访问权限允许时，可以不创建对象，直接被类调用
- **类变量：**
    - 类变量由该类的所有实例共享
    - 不用创建对象就可以访问静态成员 `类名.类属性`
- **类方法：**
    - 不用创建对象就可以访问静态成员 `类名.方法名()`
    - static 方法内部**只能访问 static 修饰的属性或方法**，不能访问非 static 的结构
    - static 方法内**不能有 this 和 super**
    - static 修饰的方法**不能被重写**

### final 关键字

- final 关键字可用于修饰**类、变量和方法**。final修饰变量时，表示该变量一旦获得初始值就不可被改变
- **final 类**：
    - final 修饰的类不可以有子类，即**不可被继承**
- **final 变量：**
    - **final 成员变量：**必须由程序员**显示地指定初始值**
    - **final 局部变量：**可以在定义时指定默认值，也可以在后续代码中赋值，但不能重复赋值。final 修饰的形参由传入的参数完成初始化，不能被赋值
- **final 方法：**
    - final 修饰的方法**不可被重写**，但可以被重载
    - 对于一个 private 修饰的方法，子类无法重写该方法，如果子类定义了一个完全相同的方法，不是方法重写，只是重新定义了一个新的方法，因此即使使用 final 修饰，也可以在子类中定义完全相同的方法

## 抽象类

- 抽象类和抽象方法必须使用 **abstract 修饰符**来定义
- 有抽象方法的类只能被定义为抽象类，抽象类里可以没有抽象方法
- **抽象方法：**
    - 抽象方法不能有方法体
    - 非默认抽象方法必须被子类重写
- **抽象类：**
    - 抽象类不能被实例化
    - 抽象类可以包含**成员变量、方法（普通方法和抽象方法）、构造器、初始化块、内部类（接口、枚举）**
    - 抽象类的构造器不能用于创建实例，主要用于被子类调用
- 注意：
    - final 和 abstract 不能同时使用
    - private 和 abstract 不能同时修饰方法
    - static 和 abstract 不能同时修饰方法，但可以修饰内部类

## 接口

- 接口时抽象方法和常量定义的集合，使用 **interface 关键字**定义
- 接口中**不能包含构造器和初始化块**
- 接口中可以包含**成员变量（静态常量）、方法（抽象实例方法、类方法、默认方法或私有方法）、内部类（内部接口、枚举）**
- **成员变量：**
    - 只能是**静态常量**，默认是由 public static final 修饰
- **方法：**
    - **抽象实例方法：**即普通方法，默认是由 public abstract 修饰
    - **类方法：**由 public static 修饰
    - **默认方法：**必须使用 default 修饰，不能使用 static 修饰
    - **私有方法：**由 private 修饰，可以有方法体，但不能使用 default 修饰，可以使用 static 修饰
    - 接口里的普通方法不能有方法实现（方法体），但类方法、默认方法、私有方法都必须有方法实现（方法体）
- 接口完全**支持多继承**
- 接口不能用于创建实例，但可以用于声明引用变量类型变量，这个变量必须**引用到其实现类的对象**
- 一个类可以实现一个或多个接口，实现接口与继承父类相似，可以获得所实现接口里定义的常量、方法
- 一个类实现了一个或多个接口之后，这个类**必须完全实现这些接口里定义的全部抽象方法（也就是重写这些抽象方法）**，否则该类也必须定义为抽象类
